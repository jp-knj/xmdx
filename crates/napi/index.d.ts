/* auto-generated by NAPI-RS */
/* eslint-disable */
/** Stateful compiler exposed to Node callers. */
export declare class XmdxCompiler {
  /** Creates a compiler that can be reused across Vite transform hooks. */
  constructor(config?: CompilerConfig | undefined | null)
  /**
   * Compiles Markdown/MDX into an Astro-compatible module string.
   *
   * Internally this delegates to `compile_ir` for parsing/rewriting, then
   * formats the legacy Astro module code. A future adapter hook can replace
   * the codegen step without changing the JS-facing signature.
   */
  compile(source: string, filepath: string, options?: FileOptions | undefined | null): CompileResult
  /**
   * Compiles multiple Markdown/MDX files in parallel using Rayon.
   *
   * This method uses the compiler's configuration for all files and processes
   * them concurrently for faster batch compilation. Returns IR results.
   *
   * # Arguments
   *
   * * `inputs` - Array of files to compile
   * * `options` - Optional batch processing options (thread count, error handling)
   *
   * # Returns
   *
   * Returns a `BatchProcessingResult` containing individual IR results and statistics.
   */
  compileBatch(inputs: Array<BatchInput>, options?: BatchOptions | undefined | null): BatchProcessingResult
  /**
   * Compiles multiple Markdown/MDX files to complete Astro modules in parallel.
   *
   * Unlike `compileBatch` which returns IR for further processing in TypeScript,
   * this method returns complete Astro module code ready for esbuild transformation.
   * This eliminates the need for TypeScript's `wrapHtmlInJsxModule` step.
   *
   * # Arguments
   *
   * * `inputs` - Array of files to compile
   * * `options` - Optional batch processing options (thread count, error handling)
   *
   * # Returns
   *
   * Returns a `ModuleBatchProcessingResult` containing complete module code and statistics.
   */
  compileBatchToModule(inputs: Array<BatchInput>, options?: BatchOptions | undefined | null): ModuleBatchProcessingResult
  /**
   * Compiles multiple MDX files in parallel using mdxjs-rs.
   *
   * Uses the compiler's configuration for JSX import source and directive
   * settings. Non-MDX files are rejected with an error.
   *
   * # Arguments
   *
   * * `inputs` - Array of MDX files to compile
   * * `options` - Optional batch processing options (thread count, error handling)
   *
   * # Returns
   *
   * Returns a `MdxBatchProcessingResult` containing individual results and statistics.
   */
  compileMdxBatch(inputs: Array<BatchInput>, options?: BatchOptions | undefined | null): MdxBatchProcessingResult
}

/** Structured batch error with a machine-readable code and human-readable message. */
export interface BatchError {
  /** Error category for programmatic handling (e.g., "PARSE_ERROR", "RENDER_ERROR"). */
  code: string
  /** Human-readable error message. */
  message: string
}

/** Input for batch processing - represents a single file to compile. */
export interface BatchInput {
  /** File identifier (typically the file path). */
  id: string
  /** Markdown/MDX source content. */
  source: string
  /** Optional filepath override for error messages and file type detection. */
  filepath?: string
}

/** Options for batch processing. */
export interface BatchOptions {
  /** Maximum number of threads to use. Defaults to number of CPU cores. */
  maxThreads?: number
  /** Whether to continue processing after an error. Defaults to true. */
  continueOnError?: boolean
}

/** Result of batch processing containing all results and statistics. */
export interface BatchProcessingResult {
  /** Individual results for each input file. */
  results: Array<BatchResult>
  /** Processing statistics. */
  stats: BatchStats
}

/** Result for a single file in a batch. */
export interface BatchResult {
  /** File identifier matching the input. */
  id: string
  /** Compilation result (present on success). */
  result?: CompileIrResult
  /** Structured error (present on failure). */
  error?: BatchError
}

/** Statistics for batch processing. */
export interface BatchStats {
  /** Total number of files processed. */
  total: number
  /** Number of successfully compiled files. */
  succeeded: number
  /** Number of failed compilations. */
  failed: number
  /** Total processing time in milliseconds. */
  processingTimeMs: number
}

/** Options for the mdast v2 block renderer. */
export interface BlockOptions {
  /** Enable directive preprocessing (:::note, etc.). Defaults to true. */
  enableDirectives?: boolean
  /** Enable smart punctuation transformations. Defaults to false. */
  enableSmartypants?: boolean
  /** Enable lazy loading for images. Defaults to false. */
  enableLazyImages?: boolean
  /** Allow raw HTML (<script>, <style>, etc.) to pass through. Defaults to true. */
  allowRawHtml?: boolean
  /** Wrap heading content in anchor links for self-linking. Defaults to false. */
  enableHeadingAutolinks?: boolean
  /** Enable math syntax ($inline$ and $$block$$). Defaults to false. */
  enableMath?: boolean
}

/** Neutral IR returned when Astro-compat codegen is disabled. */
export interface CompileIrResult {
  /** Rendered JSX output (string form). */
  html: string
  /** Hoisted imports captured during parsing (structured). */
  hoistedImports: Array<ImportSpec>
  /** Hoisted exports captured during parsing (structured). */
  hoistedExports: Array<ExportSpec>
  /** Serialized frontmatter JSON string. */
  frontmatterJson: string
  /** Heading metadata collected during parsing. */
  headings: Array<HeadingEntry>
  /** Absolute or workspace-relative file path of the source. */
  filePath: string
  /** Route URL (if provided) associated with the file. */
  url?: string
  /** Layout import path extracted from frontmatter (if any). */
  layoutImport?: string
  /** JSX runtime import source to be used by JS adapters. */
  runtimeImport: string
  /** Parse diagnostics (warnings, not errors) */
  diagnostics: Diagnostics
  /** Whether user provided their own `export default` statement. */
  hasUserDefaultExport: boolean
}

/** Options passed to the compiler constructor. */
export interface CompilerConfig {
  /** Enables GFM extensions (currently always on; placeholder for parity). */
  gfm?: boolean
  /** Enables smart punctuation substitutions (placeholder flag). */
  smartypants?: boolean
  /** Enables syntax highlighting (placeholder flag). */
  syntaxHighlighting?: boolean
  /** Overrides the module used for JSX runtime helpers. */
  jsxImportSource?: string
  /** Component registry configuration (JSON). */
  registry?: JsonValue
  /**
   * Whether to rewrite JSX code blocks to HTML format for ExpressiveCode.
   * Only set to true when ExpressiveCode is enabled.
   */
  rewriteCodeBlocks?: boolean
  /** Whether to wrap heading content in anchor links for self-linking. */
  enableHeadingAutolinks?: boolean
  /** Whether to enable math syntax ($inline$ and $$block$$). */
  math?: boolean
  /**
   * Custom directive names to recognize beyond the built-in set.
   * Each entry is a directive name (e.g., "custom-box").
   */
  customDirectiveNames?: Array<string>
  /**
   * Component name overrides for directives.
   * Maps directive name to component name (e.g., {"note": "Callout", "custom-box": "Box"}).
   */
  directiveComponentMap?: any
}

/** Result returned by the streaming compiler. */
export interface CompileResult {
  /** Compiled JavaScript/JSX module text. */
  code: string
  /** Source map in v3 format (null when unavailable). */
  map?: string
  /** JSON string containing serialized frontmatter. */
  frontmatterJson: string
  /** Heading metadata collected during compilation. */
  headings: Array<HeadingEntry>
  /** Dependencies referenced while compiling (layouts/imports). */
  imports: Array<ImportedModule>
  /** Parse diagnostics (warnings, not errors) */
  diagnostics: Diagnostics
  /** Whether user provided their own `export default` statement. */
  hasUserDefaultExport: boolean
}

/** Helper factory exposed to JavaScript for ergonomic reuse. */
export declare function createCompiler(config?: CompilerConfig | undefined | null): XmdxCompiler

/** Diagnostics returned with compilation result */
export interface Diagnostics {
  /** Non-fatal warnings */
  warnings: Array<ParseWarningEntry>
}

/** Structured export returned by the compiler IR. */
export interface ExportSpec {
  /** Raw export statement text. */
  source: string
  /** Whether this is a default export (`export default ...`). */
  isDefault: boolean
}

/** File categories supported by the compiler. */
export declare const enum FileInputType {
  /** Standard Markdown (.md) without MDX extensions. */
  Markdown = 'Markdown',
  /** Full MDX documents (.mdx) with JSX/ESM hoisting. */
  Mdx = 'Mdx'
}

/** File-specific overrides that accompany each compilation. */
export interface FileOptions {
  /** Route URL that Astro associates with the file. */
  url?: string
  /** Absolute file path (overrides the `filepath` argument when provided). */
  file?: string
  /** Explicitly sets the file type so callers can override extension-based detection. */
  fileType?: FileInputType
}

/** Parsed frontmatter document plus any parser errors. */
export interface FrontmatterResult {
  /** Structured frontmatter data represented as JSON. */
  frontmatter: JsonValue
  /** Any syntax or parsing errors surfaced by the extractor. */
  errors: Array<string>
}

/**
 * Checks if string contains PascalCase JSX tags (e.g., `<Card`, `<Aside`).
 *
 * This is used to detect nested JSX components in slot content. When components
 * are present, the slot content must be embedded directly (not via `set:html`)
 * so that Astro processes them as components rather than raw HTML.
 */
export declare function hasPascalCaseTag(s: string): boolean

/** Heading metadata returned from the compiler. */
export interface HeadingEntry {
  /** Heading depth (1-6). */
  depth: number
  /** Slugified identifier. */
  slug: string
  /** Visible heading text. */
  text: string
}

/**
 * Converts HTML entities to JSX-safe expressions.
 *
 * When slot content with nested components is embedded directly in JSX,
 * HTML entities must be handled appropriately based on context:
 * - Text content: entities → JSX expressions (e.g., `&amp;` → `{"&"}`)
 * - Attribute values: entities stay as-is (browser interprets them)
 * - JSX expression attributes: curly braces decoded (e.g., `=&#123;` → `={`)
 */
export declare function htmlEntitiesToJsx(s: string): string

/** Imported module referenced by the compiled output. */
export interface ImportedModule {
  /** Resolved file path of the import. */
  path: string
  /** Logical category (`layout`, `component`, etc.). */
  kind: string
}

/** Import category surfaced to JS callers. */
export declare const enum ImportKind {
  /** Import lifted from document root. */
  Hoisted = 'Hoisted',
  /** Import required by transforms (e.g., directive mapper). */
  Transform = 'Transform'
}

/** Structured import returned by the compiler IR. */
export interface ImportSpec {
  /** Raw import statement text. */
  source: string
  /** Logical kind (hoisted or transform-required). */
  kind: ImportKind
}

/** Result of MDX batch processing containing all results and statistics. */
export interface MdxBatchProcessingResult {
  /** Individual results for each input file. */
  results: Array<MdxBatchResult>
  /** Processing statistics. */
  stats: BatchStats
}

/** Result for a single MDX file in a batch. */
export interface MdxBatchResult {
  /** File identifier matching the input. */
  id: string
  /** Compilation result (present on success). */
  result?: MdxCompileResult
  /** Structured error (present on failure). */
  error?: BatchError
}

/**
 * Result from MDX compilation using mdxjs-rs.
 * Unlike CompileIrResult which returns JSX for further processing,
 * this returns complete JavaScript code ready for use.
 */
export interface MdxCompileResult {
  /** Compiled JavaScript code (complete module with MDXContent export). */
  code: string
  /** Serialized frontmatter JSON string. */
  frontmatterJson: string
  /** Heading metadata collected during parsing. */
  headings: Array<HeadingEntry>
}

/** Result of module batch processing containing all results and statistics. */
export interface ModuleBatchProcessingResult {
  /** Individual results for each input file. */
  results: Array<ModuleBatchResult>
  /** Processing statistics. */
  stats: BatchStats
}

/**
 * Result for a single file in a module batch.
 * Unlike BatchResult which returns IR, this returns complete module code.
 */
export interface ModuleBatchResult {
  /** File identifier matching the input. */
  id: string
  /** Compilation result with complete module code (present on success). */
  result?: CompileResult
  /** Structured error (present on failure). */
  error?: BatchError
}

/**
 * Parses markdown into structured RenderBlock objects using the mdast v2 renderer.
 *
 * This function uses the Block Architecture to return a structured representation
 * of the markdown content, allowing JavaScript to dynamically map component names
 * to actual Astro components without hardcoding in Rust.
 *
 * # Arguments
 *
 * * `input` - The markdown text to parse
 * * `opts` - Optional configuration object with:
 *   - `enable_directives`: boolean (default: true)
 *
 * # Returns
 *
 * Returns an array of RenderBlock objects. Each block is either:
 * - `{type: "html", content: "<p>...</p>"}` - Plain HTML content
 * - `{type: "component", name: "note", props: {title: "..."}, slotChildren: [...]}` - Component block
 * - `{type: "code", code: "...", lang: "ts", meta: null}` - Code block
 *
 * # Example (JavaScript)
 *
 * ```javascript
 * const { parseBlocks } = require('@xmdx/napi');
 *
 * const input = `:::note[Important]
 * This is **bold** text.
 * :::`;
 *
 * const blocks = parseBlocks(input, { enable_directives: true });
 * // blocks = [
 * //   {
 * //     type: "component",
 * //     name: "note",
 * //     props: { title: "Important" },
 * //     slotChildren: [{ type: "html", content: "<p>This is <strong>bold</strong> text.</p>" }]
 * //   }
 * // ]
 * ```
 */
export declare function parseBlocks(input: string, opts?: BlockOptions | undefined | null): ParseBlocksResult

/** Result of parseBlocks() with blocks and extracted headings. */
export interface ParseBlocksResult {
  /** Rendering blocks (HTML or Component). */
  blocks: Array<RenderBlock>
  /** Extracted heading metadata. */
  headings: Array<HeadingEntry>
}

/** Extracts YAML or TOML frontmatter without compiling the entire Markdown document. */
export declare function parseFrontmatter(content: string): FrontmatterResult

/** Parse warning returned from Rust */
export interface ParseWarningEntry {
  /** Warning type (e.g., "unclosed_code_fence") */
  warningType: string
  /** Line number where warning occurred */
  line: number
  /** Human-readable message */
  message: string
}

/**
 * Represents a rendering block returned by parse_blocks().
 *
 * JavaScript receives this as:
 * ```ts
 * type RenderBlock =
 *   | { type: "html", content: string }
 *   | { type: "component", name: string, props: Record<string, string>, slotChildren: RenderBlock[] }
 *   | { type: "code", code: string, lang?: string, meta?: string }
 * ```
 */
export interface RenderBlock {
  /** Block type: "html", "component", or "code" */
  type: string
  /** HTML content (for type="html") */
  content?: string
  /** Component name (for type="component") */
  name?: string
  /** Component props (for type="component") */
  props?: JsonValue
  /** Structured slot children (for type="component") */
  slotChildren?: Array<RenderBlock>
  /** Code content (for type="code") */
  code?: string
  /** Code language (for type="code") */
  lang?: string
  /** Code meta string (for type="code") */
  meta?: string
}
